#include "libfilezilla/encode.hpp"

namespace fz {

namespace {
template<typename DataContainer>
std::string base64_encode_impl(DataContainer const& in, base64_type type, bool pad)
{
	static_assert(sizeof(typename DataContainer::value_type) == 1, "Bad container type");

	std::string::value_type const* const base64_chars =
		 (type == base64_type::standard)
			? "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
			: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_";

	std::string ret;

	size_t len = in.size();
	size_t pos{};

	ret.reserve(((len + 2) / 3) * 4);

	while (len >= 3) {
		len -= 3;
		auto const c1 = static_cast<unsigned char>(in[pos++]);
		auto const c2 = static_cast<unsigned char>(in[pos++]);
		auto const c3 = static_cast<unsigned char>(in[pos++]);

		ret += base64_chars[(c1 >> 2) & 0x3fu];
		ret += base64_chars[((c1 & 0x3u) << 4) | ((c2 >> 4) & 0xfu)];
		ret += base64_chars[((c2 & 0xfu) << 2) | ((c3 >> 6) & 0x3u)];
		ret += base64_chars[(c3 & 0x3fu)];
	}
	if (len) {
		auto const c1 = static_cast<unsigned char>(in[pos++]);
		ret += base64_chars[(c1 >> 2) & 0x3fu];
		if (len == 2) {
			auto const c2 = static_cast<unsigned char>(in[pos++]);
			ret += base64_chars[((c1 & 0x3u) << 4) | ((c2 >> 4) & 0xfu)];
			ret += base64_chars[(c2 & 0xfu) << 2];
		}
		else {
			ret += base64_chars[(c1 & 0x3u) << 4];
			if (pad) {
				ret += '=';
			}
		}
		if (pad) {
			ret += '=';
		}
	}

	return ret;
}
}

std::string base64_encode(std::string_view const& in, base64_type type, bool pad)
{
	return base64_encode_impl(in, type, pad);
}

std::string base64_encode(std::vector<uint8_t> const& in, base64_type type, bool pad)
{
	return base64_encode_impl(in, type, pad);
}

std::string base64_decode(std::string_view const& in)
{
	unsigned char const chars[256] =
	{
	    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80, 0x80, 0xff, 0x80, 0x80, 0xff, 0xff,
	    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	    0x80, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x3e, 0xff, 0x3e, 0xff, 0x3f,
	    0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0xff, 0xff, 0xff, 0x40, 0xff, 0xff,
	    0xff, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e,
	    0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0xff, 0xff, 0xff, 0xff, 0x3f,
	    0xff, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28,
	    0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33, 0xff, 0xff, 0xff, 0xff, 0xff,
	    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
	};

	std::string ret;
	ret.reserve((in.size() / 4) * 3);

	size_t pos{};
	size_t len = in.size();

	// Trim trailing whitespace
	while (len && chars[static_cast<unsigned char>(in[len - 1])] == 0x80) {
		--len;
	}

	auto next = [&]() {
		while (pos < len) {
			auto c = chars[static_cast<unsigned char>(in[pos++])];
			if (c != 0x80u) {
				return c;
			}
		}
		return static_cast<unsigned char>(0x40u);
	};

	while (pos < len) {
		auto c1 = next();
		auto c2 = next();
		auto c3 = next();
		auto c4 = next();

		if (c1 == 0xff || c1 == 0x40 ||
		    c2 == 0xff || c2 == 0x40 ||
		    c3 == 0xff || c4 == 0xff)
		{
			// Bad input
			return std::string();
		}

		if (c4 == 0x40) {
			// Pad
			if (pos < len) {
				// Not at end of string
				return std::string();
			}
			ret += (c1 << 2) | ((c2 >> 4) & 0x3);

			if (c3 != 0x40) {
				ret += ((c2 & 0xf) << 4) | ((c3 >> 2) & 0xf);
			}
		}
		else {
			if (c3 == 0x40) {
				// Bad input
				return std::string();
			}

			ret += (c1 << 2) | ((c2 >> 4) & 0x3);
			ret += ((c2 & 0xf) << 4) | ((c3 >> 2) & 0xf);
			ret += ((c3 & 0x3) << 6) | c4;
		}
	}

	return ret;
}


namespace {
template<typename DataContainer>
std::string base32_encode_impl(DataContainer const& in, base32_type type, bool pad)
{
	static_assert(sizeof(typename DataContainer::value_type) == 1, "Bad container type");

	std::string::value_type const* const base32_chars =
		 (type == base32_type::standard)
			? "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"
			: "0123456789ABCDEFGHIJKLMNOPQRSTUV";

	std::string ret;

	size_t len = in.size();
	size_t pos{};

	ret.reserve(((len + 4) / 5) * 8);

	while (len >= 5) {
		len -= 5;
		auto const c1 = static_cast<unsigned char>(in[pos++]);
		auto const c2 = static_cast<unsigned char>(in[pos++]);
		auto const c3 = static_cast<unsigned char>(in[pos++]);
		auto const c4 = static_cast<unsigned char>(in[pos++]);
		auto const c5 = static_cast<unsigned char>(in[pos++]);

		ret += base32_chars[(c1 >> 3) & 0x1fu];
		ret += base32_chars[((c1 & 0x7u) << 2) | ((c2 >> 6) & 0x3u)];
		ret += base32_chars[(c2 >> 1) & 0x1fu];
		ret += base32_chars[((c2 & 0x1u) << 4) | ((c3 >> 4) & 0xfu)];
		ret += base32_chars[((c3 & 0xfu) << 1) | ((c4 >> 7) & 0x1u)];
		ret += base32_chars[(c4 >> 2) & 0x1fu];
		ret += base32_chars[((c4 & 0x3u) << 3) | ((c5 >> 5) & 0x7u)];
		ret += base32_chars[c5 & 0x1fu];
	}
	if (len) {
		auto const c1 = static_cast<unsigned char>(in[pos++]);
		ret += base32_chars[(c1 >> 3) & 0x1fu];
		if (len >= 2) {
			auto const c2 = static_cast<unsigned char>(in[pos++]);
			ret += base32_chars[((c1 & 0x7u) << 2) | ((c2 >> 6) & 0x3u)];
			ret += base32_chars[(c2 >> 1) & 0x1fu];
			if (len >= 3) {
				auto const c3 = static_cast<unsigned char>(in[pos++]);
				ret += base32_chars[((c2 & 0x1u) << 4) | ((c3 >> 4) & 0xfu)];
				if (len >= 4) {
					auto const c4 = static_cast<unsigned char>(in[pos++]);
					ret += base32_chars[((c3 & 0xfu) << 1) | ((c4 >> 7) & 0x1u)];
					ret += base32_chars[(c4 >> 2) & 0x1fu];
					ret += base32_chars[((c4 & 0x3u) << 3)];
					ret += '=';
				}
				else {
					ret += base32_chars[((c3 & 0xfu) << 1)];
					if (pad) {
						ret += "===";
					}
				}
			}
			else {
				ret += base32_chars[((c2 & 0x1u) << 4)];
				if (pad) {
					ret += "====";
				}
			}
		}
		else {
			ret += base32_chars[((c1 & 0x7u) << 2)];
			if (pad) {
				ret += "======";
			}
		}
	}

	return ret;
}
}

std::string base32_encode(std::string_view const& in, base32_type type, bool pad)
{
	return base32_encode_impl(in, type, pad);
}

std::string base32_encode(std::vector<uint8_t> const& in, base32_type type, bool pad)
{
	return base32_encode_impl(in, type, pad);
}


std::string base32_decode(std::string_view const& in, base32_type type)
{
	unsigned char const chars_s[256] =
	{
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80, 0x80, 0xff, 0x80, 0x80, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0x80, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0x00, 0x00, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0x40, 0xff, 0xff,
		0xff, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e,
		0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e,
		0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
	};

	unsigned char const chars_h[256] =
	{
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80, 0x80, 0xff, 0x80, 0x80, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0x80, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0xff, 0xff, 0xff, 0x40, 0xff, 0xff,
		0xff, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18,
		0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18,
		0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
	};

	auto const chars = (type == base32_type::standard) ? chars_s : chars_h;

	std::string ret;
	ret.reserve((in.size() / 8) * 5);

	size_t pos{};
	size_t len = in.size();

	// Trim trailing whitespace
	while (len && chars[static_cast<unsigned char>(in[len - 1])] == 0x80) {
		--len;
	}

	unsigned char end{};
	auto next = [&]() {
		while (pos < len) {
			auto c = chars[static_cast<unsigned char>(in[pos++])];
			if (c == 0x80u) {
				continue;
			}

			if (end) {
				if (c != end) {
					end = 0xff;
				}
				return end;
			}
			else if (c == 0xff || c == 0x40) {
				end = c;
			}

			return c;
		}
		return end ? end : static_cast<unsigned char>(0x40u);
	};

	while (pos < len) {
		auto const c1 = next();
		auto const c2 = next();
		auto const c3 = next();
		auto const c4 = next();
		auto const c5 = next();
		auto const c6 = next();
		auto const c7 = next();
		auto const c8 = next();

		if (c2 == 0x40 || c8 == 0xff) {
			// Bad input
			return std::string();
		}

		ret += (c1 << 3) | ((c2 >> 2) & 0x7);

		if (c3 != 0x40) {
			if (c4 == 0x40) {
				// Bad input
				return std::string();
			}
			ret += ((c2 & 0x3) << 6) | (c3 << 1) | ((c4 >> 4) & 0x1);

			if (c5 != 0x40) {
				ret += ((c4 & 0xf) << 4) | (c5 >> 1);

				if (c6 != 0x40) {
					if (c7 == 0x40) {
						// Bad input
						return std::string();
					}
					ret += ((c5 & 0x1) << 7) | (c6 << 2) | ((c7 >> 3) & 0x3);

					if (c8 != 0x40) {
						ret += ((c7 & 0x7) << 5) | c8;
					}
				}
			}
		}
	}

	return ret;
}


std::string percent_encode(std::string_view const& s, bool keep_slashes)
{
	std::string ret;
	ret.reserve(s.size());

	for (auto const& c : s) {
		if (!c) {
			break;
		}
		else if ((c >= '0' && c <= '9') ||
		    (c >= 'a' && c <= 'z') ||
		    (c >= 'A' && c <= 'Z') ||
		    c == '-' || c == '.' || c == '_' || c == '~')
		{
			ret += c;
		}
		else if (c == '/' && keep_slashes) {
			ret += c;
		}
		else {
			ret += '%';
			ret += int_to_hex_char<char, false>(static_cast<unsigned char>(c) >> 4);
			ret += int_to_hex_char<char, false>(c & 0xf);
		}
	}

	return ret;
}

std::string percent_encode(std::wstring_view const& s, bool keep_slashes)
{
	return percent_encode(to_utf8(s), keep_slashes);
}

std::wstring percent_encode_w(std::wstring_view const& s, bool keep_slashes)
{
	return to_wstring(percent_encode(s, keep_slashes));
}

std::string percent_decode(std::string_view const& s, bool allow_embedded_null)
{
	std::string ret;
	ret.reserve(s.size());

	char const* c = s.data();
	char const* const end = c + s.size();
	while (c < end) {
		if (*c == '%') {
			if (++c == end) {
				return std::string();
			}
			int const high = hex_char_to_int(*c);
			if (high == -1) {
				return std::string();
			}
			if (++c == end) {
				return std::string();
			}
			int const low = hex_char_to_int(*c);
			if (low == -1) {
				return std::string();
			}

			if (!high && !low && !allow_embedded_null) {
				return std::string();
			}
			ret.push_back(static_cast<char>(static_cast<uint8_t>((high << 4) + low)));
		}
		else {
			if (!*c && !allow_embedded_null) {
				return std::string();
			}
			ret.push_back(*c);
		}
		++c;
	}

	return ret;
}

}
